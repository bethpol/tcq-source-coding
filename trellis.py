#!/usr/bin/env python3
"""
trellis.py
Trellis class for TCQ
"""

import numpy as np
from scipy.optimize import minimize_scalar
from typing import Tuple

from trellis_numba import (
    build_transition_matrix_0_numba,
    fill_p_params_numba,
    encode_R_1_numba,
    encode_frac_R_numba,
)

class Trellis:
    """
    Represents a trellis structure for Trellis-Coded Quantization (TCQ) 
    with a specified source_type and distortion measure.

    Attributes:
        K (int): Number of states in the trellis.
        n (int): Number of source_type samples.
        structure (int): Encodes the trellis structure.
                         Currently supported:
                          0 - Shift-register structure
                          TO-DO:
                          1 - Branches same and down
                          2 - Fully connected
        source_type (int): Encodes the source_type and distortion measure combination.
                      Currently supported:
                          0 - M-ary PAM with Hamming distortion.
                          1 - Quadratic-Gaussian
        params (np.ndarray): Parameters corresponding to the specified source_type.
                             For M-ary PAM: np.array([M]).
        transition (np.ndarray): Transition table generated by the trellis.
        codebook (np.ndarray or None): Codebook associated with the trellis,
                                       initialized as None.
        penalties (np.ndarray or None): Stores p-parameter assignments.
    """

    def __init__(self, K: int, n: int, structure: int, source_type: int, params: np.ndarray):
        self.K: int = K
        self.n: int = n
        self.structure: int = structure
        self.source_type: int = source_type
        self.params: np.ndarray = params

        self.transition: np.ndarray = self._generate_transition()
        self.penalties: np.ndarray = self._generate_penalties()
        self.codebook: np.ndarray | None = None  # Codebook may depend on target rate

    def _generate_transition(self) -> np.ndarray:
        """
        Generates the trellis transition table based on constraint length and source_type.

        Returns:
            np.ndarray: Transition table defining state transitions.
        """
        if self.structure == 0:  # Generate shift-register trellis
            if not (self.K > 0 and (self.K & (self.K - 1)) == 0):
                print(f"K value {self.K} is not a power of 2. Transition matrix failed.")
                return None
            state_bits = np.log2(self.K)
            return build_transition_matrix_0_numba(self.K, state_bits)
        return None
    
    def _generate_codebook(self, params=[]) -> np.ndarray:
        """
        Generates the random reconstructions based on source_type type and params.

        Returns:
            np.ndarray: K*2 x n table of reconstructions
        """
        if self.source_type == 0: 
            return np.random.randint(self.params[0], size=(self.K*2, self.n))
        if self.source_type == 1:  # Quadratic Gaussian optimal reconstructions sigma^2 - D
            return np.random.normal(loc = 0, scale = (1 - params[0]), size=(self.K*2, self.n))
        return None

    def _generate_corr_codebook(self, rho: float) -> np.ndarray:
        """
        Generates negatively correlated reconstructions on branches.

        Returns:
            np.ndarray: K*2 x n table of reconstructions
        """
        if self.source_type == 1:
            # rho is negative correlation coefficient
            std = 1 - abs(rho)  # Adjust std dev if needed

            if not -1 < rho < 0:
                raise ValueError("Correlation coefficient should be negative and between -1 and 0.")

            num_pairs = self.K
            matrix = np.zeros((num_pairs * 2, self.n))

            for i in range(num_pairs):
                # Generate two correlated standard normals
                z1 = np.random.normal(0, std, size=self.n)
                z2 = rho * z1 + np.sqrt(1 - rho ** 2) * np.random.normal(0, std, size=self.n)

                # Assign to rows: odd row and even row below it
                matrix[2*i] = z1
                matrix[2*i + 1] = z2

            return matrix
        return None
    
    def _generate_penalties(self) -> np.ndarray:
        """
        Generates the random assignments for p-params.

        Returns:
            np.ndarray: K*2 x n table of 1 for phi and 0 for (1-phi).
        """
        p_params = np.zeros((self.K * 2, self.n), dtype=np.int32)
        all_choices = np.random.randint(0, 2, size=(self.K, self.n))

        fill_p_params_numba(p_params, all_choices)
        return p_params

    def encode_R_1(self, x_n: np.ndarray, R: float = 1.0) -> Tuple[np.ndarray, float, float]:
        """
        TO-DO: Write this
        """
        if R == 1.0:
            if self.source_type == 0:
                self.codebook = self._generate_codebook()
            return encode_R_1_numba(x_n, self.n, self.K, self.codebook, 
                                    self.source_type, self.transition)
        return None, -1.0, -1.0
    
    def encode_vector(
        self,
        x_n: np.ndarray,
        R: float = 1.0,
        lamb: float = 0.0,
        phi: float = 0.5, 
        rho: float = 0.0
    ) -> Tuple[np.ndarray, float, float]:        
        """
            TO-DO: Write this
            """
        if R == 1.0:
            if self.source_type == 0:
                self.codebook = self._generate_codebook()
            if self.source_type == 1:
                if self.params.size == 1:
                    D = 2 ** (-2 * R)
                    self.codebook = self._generate_codebook([D])
                elif self.params[1] == "Corr":
                    self.codebook = self._generate_corr_codebook(rho)
            return encode_R_1_numba(x_n, self.n, self.K, self.codebook, 
                                    self.source_type, self.transition)
        elif R < 1.0:  # Call separate encode routine for fractional rate support
            if self.source_type == 0:
                self.codebook = self._generate_codebook()
            if self.source_type == 1:
                D = 2 ** (-2 * R)
                self.codebook = self._generate_codebook([D])
            return encode_frac_R_numba(x_n, phi, lamb, self.n, self.K, self.codebook, self.penalties,
                                    self.source_type, self.transition)
        return None, -1.0, -1.0
        


            

def main():
    return
    


if __name__ == "__main__":
    main()
