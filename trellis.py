#!/usr/bin/env python3
"""
trellis.py
Trellis class for TCQ
"""

import numpy as np
from scipy.optimize import minimize_scalar
from scipy.stats import truncnorm
from scipy.optimize import minimize_scalar
from scipy.stats import norm
from typing import Tuple
import random

from trellis_numba import (
    build_transition_matrix_0_numba,
    fill_p_params_numba,
    encode_R_1_numba,
    encode_frac_R_numba,
)

class Trellis:
    """
    Represents a trellis structure for Trellis-Coded Quantization (TCQ) 
    with a specified source_type and distortion measure.

    Attributes:
        K (int): Number of states in the trellis.
        n (int): Number of source_type samples.
        structure (int): Encodes the trellis structure.
                         Currently supported:
                          0 - Shift-register structure
                          TO-DO:
                          1 - Branches same and down
                          2 - Fully connected
        source_type (int): Encodes the source_type and distortion measure combination.
                      Currently supported:
                          0 - M-ary PAM with Hamming distortion.
                          1 - Quadratic-Gaussian
        params (np.ndarray): Parameters corresponding to the specified source_type.
                             For M-ary PAM: np.array([M]).
        transition (np.ndarray): Transition table generated by the trellis.
        codebook (np.ndarray or None): Codebook associated with the trellis,
                                       initialized as None.
        penalties (np.ndarray or None): Stores p-parameter assignments.
    """

    def __init__(self, K: int, n: int, structure: int, source_type: int, params: np.ndarray):
        self.K: int = K
        self.n: int = n
        self.structure: int = structure
        self.source_type: int = source_type
        self.params: np.ndarray = params
        
        self.transition: np.ndarray = self._generate_transition()
        self.penalties: np.ndarray = self._generate_penalties() # Just 0/1 assignments for phi/tau
        self.codebook: np.ndarray | None = None  # Codebook may depend on target rate

    def _generate_transition(self) -> np.ndarray:
        """
        Generates the trellis transition table based on constraint length and source_type.

        Returns:
            np.ndarray: Transition table defining state transitions.
        """
        if self.structure == 0:  # Generate shift-register trellis
            if not (self.K > 0 and (self.K & (self.K - 1)) == 0):
                print(f"K value {self.K} is not a power of 2. Transition matrix failed.")
                return None
            state_bits = np.log2(self.K)
            return build_transition_matrix_0_numba(self.K, state_bits)
        elif self.structure == 1: # Generate noisy typewriter shift register trellis
            matrix = np.zeros((self.K, self.K), dtype=int)
            np.fill_diagonal(matrix, 1)
            matrix[np.arange(self.K - 1), np.arange(1, self.K)] = 1
            matrix[-1, 0] = 1
            return matrix
        return None
    
    def _generate_codebook(self, params=[]) -> np.ndarray:
        """
        Generates the random reconstructions based on source_type type and params.

        Returns:
            np.ndarray: K*2 x n table of reconstructions
        """
        if self.source_type == 0: 
            return np.random.randint(self.params[0], size=(self.K*2, self.n))
        if self.source_type == 1:  # Quadratic Gaussian optimal reconstructions sigma^2 - D
            return np.random.normal(loc = 0, scale = (1 - params[0]), size=(self.K*2, self.n))
        return None

    def _generate_corr_codebook(self, rho: float) -> np.ndarray:
        """
        Generates negatively correlated reconstructions on branches.

        Returns:
            np.ndarray: K*2 x n table of reconstructions
        """
        if self.source_type == 1:
            # rho is negative correlation coefficient
            std = 1 - abs(rho)  # Adjust std dev if needed

            if not -1 < rho <= 0:
                raise ValueError("Correlation coefficient should be negative and between -1 and 0.")

            num_pairs = self.K
            matrix = np.zeros((num_pairs * 2, self.n))

            for i in range(num_pairs):
                # Generate two correlated standard normals
                z1 = np.random.normal(0, std, size=self.n)
                z2 = rho * z1 + np.sqrt(1 - rho ** 2) * np.random.normal(0, std, size=self.n)

                # Assign to rows: odd row and even row below it
                matrix[2*i] = z1
                matrix[2*i + 1] = z2

            return matrix
        return None
    
    def _generate_custom_codebook(self, type: str, codebook_args: list) -> np.ndarray:
        """
        Generates custom codebook of selected type.
        Types: 
           PosNeg - one branch positive, one branch negative
                Requires one arg [D]
           Partition - assigns phi (1-phi) penalty branch to phi (1-phi) partition
                Requires args [D, phi]

        Returns:
            np.ndarray: K*2 x n table of trellis reconstructions for each branch
        """
        if self.source_type == 1:
            if type == "PosNeg":  # Assign phi based on either 0.5 or target phi
                phi = 0.5
            elif type == "Partition":
                phi = codebook_args[1]
            if type == "PosNeg" or type == "Partition":
                """
                matrix = np.zeros((num_pairs * 2, self.n))
                """
                scale = np.sqrt(1 - codebook_args[0])  # std
                cutoff = scale * norm.ppf(phi)
                # print(f"Scale: {scale}, Cutoff: {cutoff}")
                
                rng = np.random.default_rng()
                shape = self.penalties.shape
                total = self.penalties.size

                # Allocate result
                matrix = np.empty(shape)

                # Number of samples needed
                num_neg = np.sum(self.penalties == 1)   # below cutoff
                num_pos = total - num_neg              # above cutoff

                # Draw less than cutoff for phi branches
                neg = np.empty(num_neg)
                k = 0
                while k < num_neg:
                    x = rng.normal(0, scale, num_neg - k)
                    x = x[x < cutoff]
                    m = min(len(x), num_neg - k)
                    neg[k:k+m] = x[:m]
                    k += m

                # Draw greater than cutoff for (1-phi) branches
                pos = np.empty(num_pos)
                k = 0
                while k < num_pos:
                    x = rng.normal(0, scale, num_pos - k)
                    x = x[x >= cutoff]
                    m = min(len(x), num_pos - k)
                    pos[k:k+m] = x[:m]
                    k += m

                # Fill matrix based on mask
                matrix[self.penalties == 1] = neg
                matrix[self.penalties == 0] = pos

                return matrix
        return None

    
    def _generate_penalties(self) -> np.ndarray:
        """
        Generates the random assignments for p-params.

        Returns:
            np.ndarray: K*2 x n table of 1 for phi and 0 for (1-phi).
        """
        p_params = np.zeros((self.K * 2, self.n), dtype=np.int32)
        all_choices = np.random.randint(0, 2, size=(self.K, self.n))

        fill_p_params_numba(p_params, all_choices)
        return p_params

    def encode_R_1(self, x_n: np.ndarray, R: float = 1.0) -> Tuple[np.ndarray, float, float]:
        """
        TO-DO: Write this
        """
        if R == 1.0:
            if self.source_type == 0:
                self.codebook = self._generate_codebook()
            return encode_R_1_numba(x_n, self.n, self.K, self.codebook, 
                                    self.source_type, self.transition)
        return None, -1.0, -1.0
    
    def encode_vector(
        self,
        x_n: np.ndarray,
        target_R: float = 1.0,
        lamb: float = 0.0,
        phi: float = 0.5, 
        rho: float = 0.0,
    ) -> Tuple[np.ndarray, float, float]:        
        """
            TO-DO: Write this
        """
        if self.source_type == 0:
            self.codebook = self._generate_codebook()
        if self.source_type == 1:
            D = 2 ** (-2 * target_R)
            if len(self.params) == 0:
                self.codebook = self._generate_codebook([D])
            elif self.params[0] == "Corr":
                self.codebook = self._generate_corr_codebook(rho)
            elif self.params[0] == "PosNeg":
                self.codebook = self._generate_custom_codebook("PosNeg", [D])
            elif self.params[0] == "Partition":
                self.codebook = self._generate_custom_codebook("Partition", [D, phi])
        if target_R == 1.0:
            return encode_R_1_numba(x_n, self.n, self.K, self.codebook, 
                                    self.source_type, self.transition)
        elif target_R < 1.0:  # Call separate encode routine for fractional rate support
            return encode_frac_R_numba(x_n, phi, lamb, self.n, self.K, self.codebook, self.penalties,
                                    self.source_type, self.transition)
        return None, -1.0, -1.0
        
# Compute binary entropy function for parameter p
def binary_entropy(p):
    return -p * np.log2(p) - (1 - p) * np.log2(1 - p)

# Compute inverse binary entropy function for a given rate to find p parameter
def inverse_H(rate):
    # Define a function that returns the absolute difference between H(p) and the desired value
    def func(p):
        return abs(binary_entropy(p) - rate)
    # Use minimize_scalar to find the value of p that minimizes the absolute difference
    result = minimize_scalar(func, bounds=(1e-15, 1-1e-15), method='bounded').x
    if result > 0.5:
        return np.float64(1 - result)
    return np.float64(result)


def main():
    T = Trellis(4, 1000, 0, 1, ["Partition"])
    x = np.random.normal(1, size=1000)
    T.encode_vector(x, 0.5, 1.0, inverse_H(0.5))  # x rate lambda phi
    print(T.codebook[:, :3])
    print(T.penalties[:, :3])
    return
    

if __name__ == "__main__":
    main()
