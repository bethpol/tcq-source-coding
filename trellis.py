#!/usr/bin/env python3
"""
trellis.py
Trellis class for TCQ
"""

import numpy as np
from scipy.optimize import minimize_scalar
from scipy.stats import truncnorm
from typing import Tuple
import random

from trellis_numba import (
    build_transition_matrix_0_numba,
    fill_p_params_numba,
    encode_R_1_numba,
    encode_frac_R_numba,
)

class Trellis:
    """
    Represents a trellis structure for Trellis-Coded Quantization (TCQ) 
    with a specified source_type and distortion measure.

    Attributes:
        K (int): Number of states in the trellis.
        n (int): Number of source_type samples.
        structure (int): Encodes the trellis structure.
                         Currently supported:
                          0 - Shift-register structure
                          TO-DO:
                          1 - Branches same and down
                          2 - Fully connected
        source_type (int): Encodes the source_type and distortion measure combination.
                      Currently supported:
                          0 - M-ary PAM with Hamming distortion.
                          1 - Quadratic-Gaussian
        params (np.ndarray): Parameters corresponding to the specified source_type.
                             For M-ary PAM: np.array([M]).
        transition (np.ndarray): Transition table generated by the trellis.
        codebook (np.ndarray or None): Codebook associated with the trellis,
                                       initialized as None.
        penalties (np.ndarray or None): Stores p-parameter assignments.
    """

    def __init__(self, K: int, n: int, structure: int, source_type: int, params: np.ndarray):
        self.K: int = K
        self.n: int = n
        self.structure: int = structure
        self.source_type: int = source_type
        self.params: np.ndarray = params
        
        self.transition: np.ndarray = self._generate_transition()
        self.penalties: np.ndarray = self._generate_penalties() # Just 0/1 assignments for phi/tau
        self.codebook: np.ndarray | None = None  # Codebook may depend on target rate

    def _generate_transition(self) -> np.ndarray:
        """
        Generates the trellis transition table based on constraint length and source_type.

        Returns:
            np.ndarray: Transition table defining state transitions.
        """
        if self.structure == 0:  # Generate shift-register trellis
            if not (self.K > 0 and (self.K & (self.K - 1)) == 0):
                print(f"K value {self.K} is not a power of 2. Transition matrix failed.")
                return None
            state_bits = np.log2(self.K)
            return build_transition_matrix_0_numba(self.K, state_bits)
        elif self.structure == 1: # Generate noisy typewriter shift register trellis
            matrix = np.zeros((self.K, self.K), dtype=int)
            np.fill_diagonal(matrix, 1)
            matrix[np.arange(self.K - 1), np.arange(1, self.K)] = 1
            matrix[-1, 0] = 1
            return matrix
        return None
    
    def _generate_codebook(self, params=[]) -> np.ndarray:
        """
        Generates the random reconstructions based on source_type type and params.

        Returns:
            np.ndarray: K*2 x n table of reconstructions
        """
        if self.source_type == 0: 
            return np.random.randint(self.params[0], size=(self.K*2, self.n))
        if self.source_type == 1:  # Quadratic Gaussian optimal reconstructions sigma^2 - D
            return np.random.normal(loc = 0, scale = (1 - params[0]), size=(self.K*2, self.n))
        return None

    def _generate_corr_codebook(self, rho: float) -> np.ndarray:
        """
        Generates negatively correlated reconstructions on branches.

        Returns:
            np.ndarray: K*2 x n table of reconstructions
        """
        if self.source_type == 1:
            # rho is negative correlation coefficient
            std = 1 - abs(rho)  # Adjust std dev if needed

            if not -1 < rho <= 0:
                raise ValueError("Correlation coefficient should be negative and between -1 and 0.")

            num_pairs = self.K
            matrix = np.zeros((num_pairs * 2, self.n))

            for i in range(num_pairs):
                # Generate two correlated standard normals
                z1 = np.random.normal(0, std, size=self.n)
                z2 = rho * z1 + np.sqrt(1 - rho ** 2) * np.random.normal(0, std, size=self.n)

                # Assign to rows: odd row and even row below it
                matrix[2*i] = z1
                matrix[2*i + 1] = z2

            return matrix
        return None
    
    def _generate_custom_codebook(self, type: str, codebook_args: list) -> np.ndarray:
        """
        Generates custom codebook of selected type.
        Types: 
           PosNeg - one branch positive, one branch negative
           Partitioned - assigns phi (1-phi) penalty branch to phi (1-phi) partition

        Returns:
            np.ndarray: K*2 x n table of reconstructions
        """
        if self.source_type == 1:
            if type == "PosNeg":
                """
                matrix = np.zeros((num_pairs * 2, self.n))
                """
                cutoff = 0.0
                scale = np.sqrt(1 - codebook_args[0])
                num_pairs = self.K
                rng = np.random.default_rng()
                total = self.n * self.K
                # positives (>= cutoff)
                pos = np.empty(total)
                k = 0
                while k < total:
                    x = rng.normal(0, scale, total - k)
                    x = x[x >= cutoff]
                    m = min(len(x), total - k)
                    pos[k:k+m] = x[:m]
                    k += m

                # negatives (< phi)
                neg = np.empty(total)
                k = 0
                while k < total:
                    x = rng.normal(0, scale, total - k)
                    x = x[x < cutoff]
                    m = min(len(x), total - k)
                    neg[k:k+m] = x[:m]
                    k += m

                # assignment
                assign = rng.integers(0, 2, total)

                # reshape
                pos = pos.reshape(num_pairs, self.n)
                neg = neg.reshape(num_pairs, self.n)
                assign = assign.reshape(num_pairs, self.n)

                # fill matrix
                matrix = np.empty((2*num_pairs, self.n))
                matrix[0::2] = assign * pos + (1 - assign) * neg
                matrix[1::2] = (1 - assign) * pos + assign * neg

                return matrix
        return None
    
    def _generate_penalties(self) -> np.ndarray:
        """
        Generates the random assignments for p-params.

        Returns:
            np.ndarray: K*2 x n table of 1 for phi and 0 for (1-phi).
        """
        p_params = np.zeros((self.K * 2, self.n), dtype=np.int32)
        all_choices = np.random.randint(0, 2, size=(self.K, self.n))

        fill_p_params_numba(p_params, all_choices)
        return p_params

    def encode_R_1(self, x_n: np.ndarray, R: float = 1.0) -> Tuple[np.ndarray, float, float]:
        """
        TO-DO: Write this
        """
        if R == 1.0:
            if self.source_type == 0:
                self.codebook = self._generate_codebook()
            return encode_R_1_numba(x_n, self.n, self.K, self.codebook, 
                                    self.source_type, self.transition)
        return None, -1.0, -1.0
    
    def encode_vector(
        self,
        x_n: np.ndarray,
        R: float = 1.0,
        lamb: float = 0.0,
        phi: float = 0.5, 
        rho: float = 0.0,
    ) -> Tuple[np.ndarray, float, float]:        
        """
            TO-DO: Write this
            """
        if R == 1.0:
            if self.source_type == 0:
                self.codebook = self._generate_codebook()
            if self.source_type == 1:
                D = 2 ** (-2 * R)
                if len(self.params) == 0:
                    self.codebook = self._generate_codebook([D])
                elif self.params[0] == "Corr":
                    self.codebook = self._generate_corr_codebook(rho)
                elif self.params[0] == "PosNeg":
                    self.codebook = self._generate_custom_codebook("PosNeg", [D])
            return encode_R_1_numba(x_n, self.n, self.K, self.codebook, 
                                    self.source_type, self.transition)
        elif R < 1.0:  # Call separate encode routine for fractional rate support
            D = 2 ** (-2 * R)
            if self.source_type == 0:
                self.codebook = self._generate_codebook()
            if self.source_type == 1:
                if self.params[0] == "PosNeg":
                    self.codebook = self._generate_custom_codebook("PosNeg", [D])
                else:
                    self.codebook = self._generate_codebook([D])
            return encode_frac_R_numba(x_n, phi, lamb, self.n, self.K, self.codebook, self.penalties,
                                    self.source_type, self.transition)
        return None, -1.0, -1.0
        



def main():
    T = Trellis(8, 15, 0, 1, ["PosNeg"])
    print(T.penalties)
    x = np.random.normal(1, size=15)
    T.encode_vector(x, 1, 0.0, 0.5)  # x rate lambda phi
    print(T.codebook[:, :3])
    return
    

if __name__ == "__main__":
    main()
